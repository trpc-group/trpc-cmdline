// Tencent is pleased to support the open source community by making tRPC available.
//
// Copyright (C) 2023 THL A29 Limited, a Tencent company.
// All rights reserved.
//
// If you have downloaded a copy of the tRPC source code from Tencent,
// please note that tRPC source code is licensed under the  Apache 2.0 License,
// A copy of the Apache 2.0 License is included in this file.

// Code generated by MockGen. DO NOT EDIT.
// Source: git.go

// Package sync is a generated GoMock package.
// mockgen -source=git.go -destination=git_mock.go -package=sync
package sync

import (
	reflect "reflect"

	git "github.com/go-git/go-git/v5"
	config "github.com/go-git/go-git/v5/config"
	plumbing "github.com/go-git/go-git/v5/plumbing"
	object "github.com/go-git/go-git/v5/plumbing/object"
	storer "github.com/go-git/go-git/v5/plumbing/storer"
	ssh "github.com/go-git/go-git/v5/plumbing/transport/ssh"
	gomock "github.com/golang/mock/gomock"
)

// MockGitManager is a mock of GitManager interface.
type MockGitManager struct {
	ctrl     *gomock.Controller
	recorder *MockGitManagerMockRecorder
}

// MockGitManagerMockRecorder is the mock recorder for MockGitManager.
type MockGitManagerMockRecorder struct {
	mock *MockGitManager
}

// NewMockGitManager creates a new mock instance.
func NewMockGitManager(ctrl *gomock.Controller) *MockGitManager {
	mock := &MockGitManager{ctrl: ctrl}
	mock.recorder = &MockGitManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGitManager) EXPECT() *MockGitManagerMockRecorder {
	return m.recorder
}

// AddWithOptions mocks base method.
func (m *MockGitManager) AddWithOptions(w *git.Worktree, opts *git.AddOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddWithOptions", w, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddWithOptions indicates an expected call of AddWithOptions.
func (mr *MockGitManagerMockRecorder) AddWithOptions(w, opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddWithOptions", reflect.TypeOf((*MockGitManager)(nil).AddWithOptions), w, opts)
}

// Commit mocks base method.
func (m *MockGitManager) Commit(w *git.Worktree, msg string, opts *git.CommitOptions) (plumbing.Hash, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", w, msg, opts)
	ret0, _ := ret[0].(plumbing.Hash)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Commit indicates an expected call of Commit.
func (mr *MockGitManagerMockRecorder) Commit(w, msg, opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockGitManager)(nil).Commit), w, msg, opts)
}

// CreateRemote mocks base method.
func (m *MockGitManager) CreateRemote(r *git.Repository, c *config.RemoteConfig) (*git.Remote, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateRemote", r, c)
	ret0, _ := ret[0].(*git.Remote)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateRemote indicates an expected call of CreateRemote.
func (mr *MockGitManagerMockRecorder) CreateRemote(r, c interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRemote", reflect.TypeOf((*MockGitManager)(nil).CreateRemote), r, c)
}

// CreateTag mocks base method.
func (m *MockGitManager) CreateTag(r *git.Repository, name string, hash plumbing.Hash, opts *git.CreateTagOptions) (*plumbing.Reference, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTag", r, name, hash, opts)
	ret0, _ := ret[0].(*plumbing.Reference)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateTag indicates an expected call of CreateTag.
func (mr *MockGitManagerMockRecorder) CreateTag(r, name, hash, opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTag", reflect.TypeOf((*MockGitManager)(nil).CreateTag), r, name, hash, opts)
}

// Head mocks base method.
func (m *MockGitManager) Head(r *git.Repository) (*plumbing.Reference, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Head", r)
	ret0, _ := ret[0].(*plumbing.Reference)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Head indicates an expected call of Head.
func (mr *MockGitManagerMockRecorder) Head(r interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Head", reflect.TypeOf((*MockGitManager)(nil).Head), r)
}

// NewPublicKeysFromFile mocks base method.
func (m *MockGitManager) NewPublicKeysFromFile(user, pemFile, password string) (*ssh.PublicKeys, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewPublicKeysFromFile", user, pemFile, password)
	ret0, _ := ret[0].(*ssh.PublicKeys)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewPublicKeysFromFile indicates an expected call of NewPublicKeysFromFile.
func (mr *MockGitManagerMockRecorder) NewPublicKeysFromFile(user, pemFile, password interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewPublicKeysFromFile", reflect.TypeOf((*MockGitManager)(nil).NewPublicKeysFromFile), user, pemFile, password)
}

// PlainClone mocks base method.
func (m *MockGitManager) PlainClone(path string, isBare bool, o *git.CloneOptions) (*git.Repository, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PlainClone", path, isBare, o)
	ret0, _ := ret[0].(*git.Repository)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PlainClone indicates an expected call of PlainClone.
func (mr *MockGitManagerMockRecorder) PlainClone(path, isBare, o interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PlainClone", reflect.TypeOf((*MockGitManager)(nil).PlainClone), path, isBare, o)
}

// PlainInit mocks base method.
func (m *MockGitManager) PlainInit(path string, isBare bool) (*git.Repository, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PlainInit", path, isBare)
	ret0, _ := ret[0].(*git.Repository)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PlainInit indicates an expected call of PlainInit.
func (mr *MockGitManagerMockRecorder) PlainInit(path, isBare interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PlainInit", reflect.TypeOf((*MockGitManager)(nil).PlainInit), path, isBare)
}

// Push mocks base method.
func (m *MockGitManager) Push(r *git.Repository, o *git.PushOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Push", r, o)
	ret0, _ := ret[0].(error)
	return ret0
}

// Push indicates an expected call of Push.
func (mr *MockGitManagerMockRecorder) Push(r, o interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockGitManager)(nil).Push), r, o)
}

// Remote mocks base method.
func (m *MockGitManager) Remote(r *git.Repository, name string) (*git.Remote, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Remote", r, name)
	ret0, _ := ret[0].(*git.Remote)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Remote indicates an expected call of Remote.
func (mr *MockGitManagerMockRecorder) Remote(r, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remote", reflect.TypeOf((*MockGitManager)(nil).Remote), r, name)
}

// TagObject mocks base method.
func (m *MockGitManager) TagObject(r *git.Repository, h plumbing.Hash) (*object.Tag, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TagObject", r, h)
	ret0, _ := ret[0].(*object.Tag)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TagObject indicates an expected call of TagObject.
func (mr *MockGitManagerMockRecorder) TagObject(r, h interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TagObject", reflect.TypeOf((*MockGitManager)(nil).TagObject), r, h)
}

// TagObjects mocks base method.
func (m *MockGitManager) TagObjects(r *git.Repository) (*object.TagIter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TagObjects", r)
	ret0, _ := ret[0].(*object.TagIter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TagObjects indicates an expected call of TagObjects.
func (mr *MockGitManagerMockRecorder) TagObjects(r interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TagObjects", reflect.TypeOf((*MockGitManager)(nil).TagObjects), r)
}

// Tags mocks base method.
func (m *MockGitManager) Tags(r *git.Repository) (storer.ReferenceIter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tags", r)
	ret0, _ := ret[0].(storer.ReferenceIter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Tags indicates an expected call of Tags.
func (mr *MockGitManagerMockRecorder) Tags(r interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tags", reflect.TypeOf((*MockGitManager)(nil).Tags), r)
}

// Worktree mocks base method.
func (m *MockGitManager) Worktree(r *git.Repository) (*git.Worktree, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Worktree", r)
	ret0, _ := ret[0].(*git.Worktree)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Worktree indicates an expected call of Worktree.
func (mr *MockGitManagerMockRecorder) Worktree(r interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Worktree", reflect.TypeOf((*MockGitManager)(nil).Worktree), r)
}
